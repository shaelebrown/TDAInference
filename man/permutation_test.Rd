% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/inference.R
\name{permutation_test}
\alias{permutation_test}
\title{Permutation test for persistence diagrams}
\usage{
permutation_test(
  ...,
  iterations = 100,
  p = 2,
  q = 2,
  dims = c(0, 1),
  paired = F,
  distance = "wasserstein",
  sigma = NULL,
  verbose = FALSE
)
}
\arguments{
\item{...}{groups of persistence diagrams, outputted from a homology calculation in TDA.}

\item{iterations}{the number of iterations for permuting group labels, default 100.}

\item{p}{the wasserstein parameter, number at least 1 (and Inf if using the bottleneck distance), default 2.}

\item{q}{a finite number at least 1 for exponentiation in the Turner loss function, default 2.}

\item{dims}{a numeric vector of the homological dimensions in which the test is to be carried out, default c(0,1).}

\item{paired}{a boolean flag for if there is a second-order pairing between diagrams at the same index in different groups. Default value is False.}

\item{distance}{a string which determines which type of distance calculation to carry out, either "wasserstein" (default) or "fisher".}

\item{sigma}{the positive bandwith for the Fisher information metric, default NULL.}

\item{verbose}{a boolean flag for if the time duration of the function call should be printed, default False.}
}
\value{
list with dimensions used (named vector), permutation loss values in each dimension (named list), test statistics in each dimension (named vector)
                  a p-value for each dimension (named vector) and the time duration of the function call.
}
\description{
Permutation test for finding differences between groups of persistence diagrams,
based on the paper \url{https://link.springer.com/article/10.1007/s41468-017-0008-7}. The test is
carried out in parallel and optimized in order to not recompute already-calculated distances.
Like in \url{https://github.com/hassan-abdallah/Statistical_Inference_PH_fMRI/blob/main/Abdallah_et_al_Statistical_Inference_PH_fMRI.pdf}
an option is provided for pairing diagrams between groups to reduce variance (boost statistical power), and
like it was suggested in the original paper functionality is provided for an arbitrary number of groups (not just 2).
}
\details{
The `...` parameter should be a number of lists of persistence diagrams, outputted from a
TDA calculation like \code{\link[TDA]{ripsDiag}} or a \code{\link{diagram_to_df}} function call. The `iterations` parameter should be the number of permutations
desired for generating the null distribution. The `p` parameter is the wasserstein power, and `q`
is the exponent for distances. `dims` is a numeric vector of the homological dimensions in which
to carry out the test. The `paired` parameter is a boolean flag for whether there are correspondences
between diagrams at the same location across groups, as this affects which permutations are permissible
when generating the null distribution. The `distance` parameter determines which distance metric
should be used between persistence diagrams. The `sigma` parameter is the positive bandwith for the
Fisher information metric `verbose` determines if the time duration of the function call should be printed.
}
\examples{

# create three groups of persistence diagrams on 2D Gaussians using TDA
g1 <- lapply(X = 1:3,FUN = function(X){

diag <- TDA::ripsDiag(data.frame(x = rnorm(100,mean = 0,sd = 1),
y = rnorm(100,mean = 0,sd = 1)),
maxscale = 1,
maxdimension = 1)
df <- diagram_to_df(d = diag)
return(df)

})

g2 <- lapply(X = 1:3,FUN = function(X){

diag <- TDA::ripsDiag(data.frame(x = rnorm(100,mean = 0,sd = 1),
y = rnorm(100,mean = 0,sd = 1)),
maxscale = 1,
maxdimension = 1)
df <- diagram_to_df(d = diag)
return(df)

})

g3 <- lapply(X = 1:3,FUN = function(X){

diag <- TDA::ripsDiag(data.frame(x = rnorm(100,mean = 0,sd = 1),
y = rnorm(100,mean = 0,sd = 1)),
maxscale = 1,
maxdimension = 1)
df <- diagram_to_df(d = diag)
return(df)

})

# do permutation test with 20 iterations, p,q = 2, in dimensions 0 and 1, with
# no pairing using persistence Fisher distance, sigma = 1, and printing the time duration
perm_test = permutation_test(g1,g2,g3,
iterations = 20,
distance = "fisher",
sigma = 1, 
verbose = TRUE)
}
