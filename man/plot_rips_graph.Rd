% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/rips_complexes.R
\name{plot_rips_graph}
\alias{plot_rips_graph}
\title{Plot a Rips graph using the \link{igraph} package.}
\usage{
plot_rips_graph(
  graphs,
  eps,
  cols = NULL,
  component_of = NULL,
  plot_isolated_vertices = FALSE,
  return_layout = FALSE,
  vertex_labels = TRUE
)
}
\arguments{
\item{graphs}{the output of a `rips_graphs` function call.}

\item{eps}{the numeric radius of the graph in `graphs` to plot.}

\item{cols}{an optional character vector of vertex colors, default `NULL`.}

\item{component_of}{a vertex name, only the component of the graph containing that vertex will be plotted (useful for identifying representative (co)cycles in graphs). Default `NULL` (plot the whole graph).}

\item{plot_isolated_vertices}{a boolean representing whether or not to plot isolated vertices, default `FALSE`.}

\item{return_layout}{a boolean representing whether or not to return the plotting layout (x-y coordinates of each vertex) and the vertex labels, default `FALSE`.}

\item{vertex_labels}{a boolean representing whether or not to plot vertex labels, default `TRUE`.}
}
\value{
if `return_layout` is `TRUE` then a list with elements "layout" (the numeric matrix of vertex x-y coordinates) and "vertices" (character vertex labels), otherwise the function does not return anything.
}
\description{
This function will throw an error if the \link{igraph} package is not installed.
}
\examples{

if(require("TDA") & require("igraph"))
{
  # simulate data from the unit circle and calculate 
  # its diagram
  df <- TDA::circleUnif(n = 25)
  diag <- TDA::ripsDiag(df,maxdimension = 1,maxscale = 2)
  
  # get minimum death radius of any data cluster
  min_death_H0 <- 
  min(diag$diagram[which(diag$diagram[,1] == 0),3L])
  
  # get birth and death radius of the loop
  loop_birth <- as.numeric(diag$diagram[nrow(diag$diagram),2L])
  loop_death <- as.numeric(diag$diagram[nrow(diag$diagram),3L])

  # compute Rips-Vietoris graphs at radii half of 
  # min_death_H0 and the mean of loop_birth and 
  # loop_death, returning clusters
  graphs <- rips_graphs(X = df,eps = 
  c(0.5*min_death_H0,(loop_birth + loop_death)/2))
  
  # plot graph of smaller (first) radius
  plot_rips_graph(graphs = graphs,eps = 0.5*min_death_H0)
  
  # plot graph of larger (second) radius
  plot_rips_graph(graphs = graphs,eps = (loop_birth + loop_death)/2)
  
  # repeat but with rownames for df, each vertex
  # will be plotted with its rownames
  rownames(df) <- paste0("V",1:25)
  graphs <- rips_graphs(X = df,eps = 
  c(0.5*min_death_H0,(loop_birth + loop_death)/2))
  plot_rips_graph(graphs = graphs,eps = 0.5*min_death_H0)
  
  # plot without vertex labels
  plot_rips_graph(graphs = graphs,eps = 0.5*min_death_H0,
                  vertex_labels = FALSE)
  
  # remove isolated vertices
  plot_rips_graph(graphs = graphs,eps = 0.5*min_death_H0,
                  plot_isolated_vertices = FALSE)
                 
  # plot only the graph component containing vertex "1"
  plot_rips_graph(graphs = graphs,eps = 0.5*min_death_H0,
                  component_of = 1)
 
  # return the layout of the graph for further
  # plotting customization
  plot_info <- plot_rips_graph(graphs = graphs,eps = 0.5*min_death_H0,
                               return_layout = TRUE)
  
}
}
\author{
Shael Brown - \email{shaelebrown@gmail.com}
}
